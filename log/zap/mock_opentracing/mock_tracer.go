// Code generated by MockGen. DO NOT EDIT.

// Copyright (c) 2020 The Jaeger Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Source: vendor/github.com/opentracing/opentracing-go/tracer.go

// Package mock_opentracing is a generated GoMock package.
package mock_opentracing

import (
	gomock "github.com/golang/mock/gomock"
	opentracing "github.com/opentracing/opentracing-go"
	reflect "reflect"
)

// MockTracer is a mock of Tracer interface
type MockTracer struct {
	ctrl     *gomock.Controller
	recorder *MockTracerMockRecorder
}

// MockTracerMockRecorder is the mock recorder for MockTracer
type MockTracerMockRecorder struct {
	mock *MockTracer
}

// NewMockTracer creates a new mock instance
func NewMockTracer(ctrl *gomock.Controller) *MockTracer {
	mock := &MockTracer{ctrl: ctrl}
	mock.recorder = &MockTracerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTracer) EXPECT() *MockTracerMockRecorder {
	return m.recorder
}

// StartSpan mocks base method
func (m *MockTracer) StartSpan(operationName string, opts ...opentracing.StartSpanOption) opentracing.Span {
	m.ctrl.T.Helper()
	varargs := []interface{}{operationName}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartSpan", varargs...)
	ret0, _ := ret[0].(opentracing.Span)
	return ret0
}

// StartSpan indicates an expected call of StartSpan
func (mr *MockTracerMockRecorder) StartSpan(operationName interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{operationName}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSpan", reflect.TypeOf((*MockTracer)(nil).StartSpan), varargs...)
}

// Inject mocks base method
func (m *MockTracer) Inject(sm opentracing.SpanContext, format, carrier interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Inject", sm, format, carrier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Inject indicates an expected call of Inject
func (mr *MockTracerMockRecorder) Inject(sm, format, carrier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inject", reflect.TypeOf((*MockTracer)(nil).Inject), sm, format, carrier)
}

// Extract mocks base method
func (m *MockTracer) Extract(format, carrier interface{}) (opentracing.SpanContext, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Extract", format, carrier)
	ret0, _ := ret[0].(opentracing.SpanContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Extract indicates an expected call of Extract
func (mr *MockTracerMockRecorder) Extract(format, carrier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Extract", reflect.TypeOf((*MockTracer)(nil).Extract), format, carrier)
}

// MockStartSpanOption is a mock of StartSpanOption interface
type MockStartSpanOption struct {
	ctrl     *gomock.Controller
	recorder *MockStartSpanOptionMockRecorder
}

// MockStartSpanOptionMockRecorder is the mock recorder for MockStartSpanOption
type MockStartSpanOptionMockRecorder struct {
	mock *MockStartSpanOption
}

// NewMockStartSpanOption creates a new mock instance
func NewMockStartSpanOption(ctrl *gomock.Controller) *MockStartSpanOption {
	mock := &MockStartSpanOption{ctrl: ctrl}
	mock.recorder = &MockStartSpanOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStartSpanOption) EXPECT() *MockStartSpanOptionMockRecorder {
	return m.recorder
}

// Apply mocks base method
func (m *MockStartSpanOption) Apply(arg0 *opentracing.StartSpanOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Apply", arg0)
}

// Apply indicates an expected call of Apply
func (mr *MockStartSpanOptionMockRecorder) Apply(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockStartSpanOption)(nil).Apply), arg0)
}
